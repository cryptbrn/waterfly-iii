// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, unused_import

import 'package:json_annotation/json_annotation.dart';

import 'bill_repeat_frequency.dart';
import 'paid_dates.dart';

part 'bill.g.dart';

@JsonSerializable()
class Bill {
  const Bill({
    required this.createdAt,
    required this.updatedAt,
    required this.currencyId,
    required this.currencyCode,
    required this.currencySymbol,
    required this.currencyDecimalPlaces,
    required this.name,
    required this.amountMin,
    required this.amountMax,
    required this.date,
    required this.endDate,
    required this.extensionDate,
    required this.repeatFreq,
    required this.skip,
    required this.active,
    required this.order,
    required this.notes,
    required this.nextExpectedMatch,
    required this.nextExpectedMatchDiff,
    required this.objectGroupId,
    required this.objectGroupOrder,
    required this.objectGroupTitle,
    required this.payDates,
    required this.paidDates,
  });
  
  factory Bill.fromJson(Map<String, Object?> json) => _$BillFromJson(json);
  
  @JsonKey(name: 'created_at')
  final DateTime createdAt;
  @JsonKey(name: 'updated_at')
  final DateTime updatedAt;

  /// Use either currency_id or currency_code
  @JsonKey(name: 'currency_id')
  final String currencyId;

  /// Use either currency_id or currency_code
  @JsonKey(name: 'currency_code')
  final String currencyCode;
  @JsonKey(name: 'currency_symbol')
  final String currencySymbol;
  @JsonKey(name: 'currency_decimal_places')
  final int currencyDecimalPlaces;
  final String name;
  @JsonKey(name: 'amount_min')
  final String amountMin;
  @JsonKey(name: 'amount_max')
  final String amountMax;
  final DateTime date;

  /// The date after which this bill is no longer valid or applicable
  @JsonKey(name: 'end_date')
  final DateTime? endDate;

  /// The date before which the bill must be renewed (or cancelled)
  @JsonKey(name: 'extension_date')
  final DateTime? extensionDate;
  @JsonKey(name: 'repeat_freq')
  final BillRepeatFrequency repeatFreq;

  /// How often the bill must be skipped. 1 means a bi-monthly bill.
  final int skip;

  /// If the bill is active.
  final bool active;

  /// Order of the bill.
  final int order;
  final String? notes;

  /// When the bill is expected to be due.
  @JsonKey(name: 'next_expected_match')
  final DateTime? nextExpectedMatch;

  /// Formatted (locally) when the bill is due.
  @JsonKey(name: 'next_expected_match_diff')
  final String? nextExpectedMatchDiff;

  /// The group ID of the group this object is part of. NULL if no group.
  @JsonKey(name: 'object_group_id')
  final String? objectGroupId;

  /// The order of the group. At least 1, for the highest sorting.
  @JsonKey(name: 'object_group_order')
  final int? objectGroupOrder;

  /// The name of the group. NULL if no group.
  @JsonKey(name: 'object_group_title')
  final String? objectGroupTitle;

  /// Array of future dates when the bill is expected to be paid. Autogenerated.
  @JsonKey(name: 'pay_dates')
  final List<DateTime> payDates;

  /// Array of past transactions when the bill was paid.
  @JsonKey(name: 'paid_dates')
  final List<PaidDates> paidDates;

  Map<String, Object?> toJson() => _$BillToJson(this);
}
