// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, unused_import

import 'package:json_annotation/json_annotation.dart';

import 'paid_dates.dart';
import 'subscription_repeat_property.dart';

part 'subscription.g.dart';

@JsonSerializable()
class Subscription {
  const Subscription({
    required this.name,
    required this.amountMin,
    required this.amountMax,
    required this.date,
    required this.repeatFreq,
    this.createdAt,
    this.updatedAt,
    this.nativeAmountMin,
    this.nativeAmountMax,
    this.currencyId,
    this.currencyCode,
    this.currencySymbol,
    this.currencyDecimalPlaces,
    this.nativeCurrencyId,
    this.nativeCurrencyCode,
    this.nativeCurrencySymbol,
    this.nativeCurrencyDecimalPlaces,
    this.endDate,
    this.extensionDate,
    this.skip,
    this.active,
    this.order,
    this.notes,
    this.objectGroupId,
    this.objectGroupOrder,
    this.objectGroupTitle,
    this.nextExpectedMatch,
    this.nextExpectedMatchDiff,
    this.payDates,
    this.paidDates,
  });

  factory Subscription.fromJson(Map<String, Object?> json) =>
      _$SubscriptionFromJson(json);

  @JsonKey(name: 'created_at')
  final DateTime? createdAt;
  @JsonKey(name: 'updated_at')
  final DateTime? updatedAt;
  final String name;
  @JsonKey(name: 'amount_min')
  final String amountMin;
  @JsonKey(name: 'amount_max')
  final String amountMax;
  @JsonKey(name: 'native_amount_min')
  final String? nativeAmountMin;
  @JsonKey(name: 'native_amount_max')
  final String? nativeAmountMax;

  /// Use either currency_id or currency_code
  @JsonKey(name: 'currency_id')
  final String? currencyId;

  /// Use either currency_id or currency_code
  @JsonKey(name: 'currency_code')
  final String? currencyCode;
  @JsonKey(name: 'currency_symbol')
  final String? currencySymbol;
  @JsonKey(name: 'currency_decimal_places')
  final int? currencyDecimalPlaces;
  @JsonKey(name: 'native_currency_id')
  final String? nativeCurrencyId;
  @JsonKey(name: 'native_currency_code')
  final String? nativeCurrencyCode;
  @JsonKey(name: 'native_currency_symbol')
  final String? nativeCurrencySymbol;
  @JsonKey(name: 'native_currency_decimal_places')
  final int? nativeCurrencyDecimalPlaces;
  final DateTime date;

  /// The date after which this bill is no longer valid or applicable
  @JsonKey(name: 'end_date')
  final DateTime? endDate;

  /// The date before which the bill must be renewed (or cancelled)
  @JsonKey(name: 'extension_date')
  final DateTime? extensionDate;
  @JsonKey(name: 'repeat_freq')
  final SubscriptionRepeatProperty repeatFreq;

  /// How often the bill must be skipped. 1 means a bi-monthly bill.
  final int? skip;

  /// If the bill is active.
  final bool? active;

  /// Order of the bill.
  final int? order;
  final String? notes;

  /// The group ID of the group this object is part of. NULL if no group.
  @JsonKey(name: 'object_group_id')
  final String? objectGroupId;

  /// The order of the group. At least 1, for the highest sorting.
  @JsonKey(name: 'object_group_order')
  final int? objectGroupOrder;

  /// The name of the group. NULL if no group.
  @JsonKey(name: 'object_group_title')
  final String? objectGroupTitle;

  /// When the bill is expected to be due.
  @JsonKey(name: 'next_expected_match')
  final DateTime? nextExpectedMatch;

  /// Formatted (locally) when the bill is due.
  @JsonKey(name: 'next_expected_match_diff')
  final String? nextExpectedMatchDiff;

  /// Array of future dates when the bill is expected to be paid. Autogenerated.
  @JsonKey(name: 'pay_dates')
  final List<DateTime>? payDates;

  /// Array of past transactions when the bill was paid.
  @JsonKey(name: 'paid_dates')
  final List<PaidDates>? paidDates;

  Map<String, Object?> toJson() => _$SubscriptionToJson(this);
}
